<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Programmation Lin√©aire Dynamique</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: #764ba2;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .config-section {
            background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .config-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #1976d2;
            margin-bottom: 20px;
            text-align: center;
        }

        .config-row {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .config-item {
            display: flex;
            align-items: center;
            gap: 10px;
            background: white;
            padding: 15px 25px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .config-label {
            font-weight: bold;
            color: #764ba2;
        }

        .input-section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 30px;
        }

        .objective-section {
            background: #e3f2fd;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .objective-title {
            font-weight: bold;
            color: #1976d2;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .objective-inputs {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .constraint-group {
            margin-bottom: 15px;
            padding: 15px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .constraint-label {
            font-weight: bold;
            color: #764ba2;
            margin-bottom: 10px;
            font-size: 1em;
        }

        .constraint-inputs {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        input[type="number"] {
            width: 70px;
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 15px;
            transition: border-color 0.3s;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
        }

        select {
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 15px;
            background: white;
            cursor: pointer;
        }

        .operator {
            font-size: 1.1em;
            font-weight: bold;
            color: #764ba2;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 10px;
            font-size: 1.1em;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            display: block;
            margin: 20px auto;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .graph-container {
            position: relative;
            height: 600px;
            margin-bottom: 30px;
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
        }

        .result-section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 15px;
            margin-top: 20px;
        }

        .result-title {
            font-size: 1.5em;
            color: #667eea;
            margin-bottom: 15px;
            font-weight: bold;
        }

        .result-content {
            background: white;
            padding: 20px;
            border-radius: 10px;
            font-size: 1.05em;
            line-height: 1.8;
        }

        .optimal-solution {
            color: #28a745;
            font-weight: bold;
            font-size: 1.3em;
            margin: 15px 0;
            padding: 15px;
            background: #d4edda;
            border-radius: 8px;
        }

        .vertices-list {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            max-height: 400px;
            overflow-y: auto;
        }

        .vertex-item {
            padding: 8px;
            margin: 5px 0;
            background: white;
            border-left: 4px solid #667eea;
            border-radius: 4px;
        }

        .no-solution {
            color: #dc3545;
            font-weight: bold;
            font-size: 1.2em;
        }

        .warning-box {
            margin-top: 15px;
            padding: 15px;
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            border-radius: 8px;
        }

        #graphSection {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìä R√©solution Graphique - Programmation Lin√©aire</h1>
        <div class="subtitle">Syst√®me Dynamique Adaptable</div>
        
        <div class="config-section">
            <div class="config-title">‚öôÔ∏è Configuration du Probl√®me</div>
            <div class="config-row">
                <div class="config-item">
                    <span class="config-label">Nombre de variables:</span>
                    <input type="number" id="numVars" value="2" min="2" max="2" onchange="validateAndGenerate()">
                </div>
                <div class="config-item">
                    <span class="config-label">Nombre de contraintes:</span>
                    <input type="number" id="numConstraints" value="5" min="1" max="20" onchange="validateAndGenerate()">
                </div>
            </div>
            <button onclick="generateProblem()" style="margin: 10px auto;">üîÑ G√©n√©rer le Probl√®me</button>
            <div class="warning-box" id="warningBox" style="display: none;">
                ‚ö†Ô∏è <strong>Note:</strong> La visualisation graphique n'est disponible que pour les probl√®mes √† 2 variables.
                Pour 3+ variables, seule la solution num√©rique sera calcul√©e.
            </div>
        </div>

        <div id="problemSection" style="display: none;">
            <div class="input-section">
                <div class="objective-section">
                    <div class="objective-title">üéØ Fonction Objectif:</div>
                    <div class="objective-inputs" id="objectiveInputs"></div>
                </div>

                <div style="font-weight: bold; margin-bottom: 15px; color: #667eea; font-size: 1.1em;">Contraintes:</div>
                <div id="constraintsContainer"></div>

                <div style="margin-top: 20px; padding: 10px; background: #e3f2fd; border-radius: 8px;">
                    <strong>Note:</strong> Toutes les variables sont automatiquement ‚â• 0
                </div>

                <button onclick="solve()">üîç R√©soudre le Probl√®me</button>
            </div>
        </div>

        <div id="graphSection">
            <div class="graph-container">
                <canvas id="myChart"></canvas>
            </div>
        </div>

        <div class="result-section" id="resultSection" style="display: none;">
            <div class="result-title">üìã R√©sultats de l'Optimisation</div>
            <div class="result-content" id="resultContent"></div>
        </div>
    </div>

    <script>
        let chart = null;
        let numVars = 2;
        let numConstraints = 5;

        function validateAndGenerate() {
            const vars = parseInt(document.getElementById('numVars').value);
            const constraints = parseInt(document.getElementById('numConstraints').value);
            
            if (vars < 2) {
                document.getElementById('numVars').value = 2;
            } else if (vars > 2) {
                document.getElementById('warningBox').style.display = 'block';
            } else {
                document.getElementById('warningBox').style.display = 'none';
            }
            
            if (constraints < 1) {
                document.getElementById('numConstraints').value = 1;
            } else if (constraints > 20) {
                document.getElementById('numConstraints').value = 20;
            }
        }

        function generateProblem() {
            numVars = parseInt(document.getElementById('numVars').value);
            numConstraints = parseInt(document.getElementById('numConstraints').value);
            
            // G√©n√©rer la fonction objectif
            let objHTML = `
                <select id="objType">
                    <option value="max">Maximiser</option>
                    <option value="min">Minimiser</option>
                </select>
                <span class="operator">Z =</span>
            `;
            
            for (let i = 1; i <= numVars; i++) {
                const varName = i === 1 ? 'x' : (i === 2 ? 'y' : `x${i}`);
                objHTML += `
                    <input type="number" id="c${i}" value="${i}" step="0.1">
                    <span class="operator">${varName}</span>
                `;
                if (i < numVars) {
                    objHTML += `<span class="operator">+</span>`;
                }
            }
            
            document.getElementById('objectiveInputs').innerHTML = objHTML;
            
            // G√©n√©rer les contraintes
            let constraintsHTML = '';
            for (let j = 1; j <= numConstraints; j++) {
                constraintsHTML += `
                    <div class="constraint-group">
                        <div class="constraint-label">Contrainte ${j}:</div>
                        <div class="constraint-inputs">
                `;
                
                for (let i = 1; i <= numVars; i++) {
                    const varName = i === 1 ? 'x' : (i === 2 ? 'y' : `x${i}`);
                    constraintsHTML += `
                        <input type="number" id="a${j}_${i}" value="1" step="0.1">
                        <span class="operator">${varName}</span>
                    `;
                    if (i < numVars) {
                        constraintsHTML += `<span class="operator">+</span>`;
                    }
                }
                
                constraintsHTML += `
                            <select id="op${j}">
                                <option value="<=">‚â§</option>
                                <option value=">=">‚â•</option>
                                <option value="=">=</option>
                            </select>
                            <input type="number" id="d${j}" value="${10 * j}" step="0.1">
                        </div>
                    </div>
                `;
            }
            
            document.getElementById('constraintsContainer').innerHTML = constraintsHTML;
            document.getElementById('problemSection').style.display = 'block';
            document.getElementById('resultSection').style.display = 'none';
            
            if (numVars === 2) {
                document.getElementById('graphSection').style.display = 'block';
            } else {
                document.getElementById('graphSection').style.display = 'none';
            }
        }

        function getObjective() {
            const type = document.getElementById('objType').value;
            const coeffs = [];
            for (let i = 1; i <= numVars; i++) {
                coeffs.push(parseFloat(document.getElementById('c' + i).value));
            }
            return { type, coeffs };
        }

        function getConstraints() {
            const constraints = [];
            for (let j = 1; j <= numConstraints; j++) {
                const coeffs = [];
                for (let i = 1; i <= numVars; i++) {
                    coeffs.push(parseFloat(document.getElementById('a' + j + '_' + i).value));
                }
                constraints.push({
                    coeffs: coeffs,
                    op: document.getElementById('op' + j).value,
                    rhs: parseFloat(document.getElementById('d' + j).value)
                });
            }
            
            // Ajouter les contraintes de non-n√©gativit√©
            for (let i = 0; i < numVars; i++) {
                const coeffs = new Array(numVars).fill(0);
                coeffs[i] = 1;
                constraints.push({ coeffs: coeffs, op: '>=', rhs: 0 });
            }
            
            return constraints;
        }

        function checkPoint(point, constraints) {
            for (let c of constraints) {
                let val = 0;
                for (let i = 0; i < point.length; i++) {
                    val += c.coeffs[i] * point[i];
                }
                
                if (c.op === '<=' && val > c.rhs + 0.0001) return false;
                if (c.op === '>=' && val < c.rhs - 0.0001) return false;
                if (c.op === '=' && Math.abs(val - c.rhs) > 0.0001) return false;
            }
            return true;
        }

        function findIntersection2D(c1, c2) {
            const det = c1.coeffs[0] * c2.coeffs[1] - c2.coeffs[0] * c1.coeffs[1];
            if (Math.abs(det) < 0.0001) return null;
            
            const x = (c1.rhs * c2.coeffs[1] - c2.rhs * c1.coeffs[1]) / det;
            const y = (c1.coeffs[0] * c2.rhs - c2.coeffs[0] * c1.rhs) / det;
            return [x, y];
        }

        function evaluateObjective(point, objective) {
            let z = 0;
            for (let i = 0; i < point.length; i++) {
                z += objective.coeffs[i] * point[i];
            }
            return z;
        }

        function solve() {
            const objective = getObjective();
            const constraints = getConstraints();
            
            if (numVars === 2) {
                solve2D(objective, constraints);
            } else {
                solveND(objective, constraints);
            }
        }

        function solve2D(objective, constraints) {
            const vertices = [];
            
            for (let i = 0; i < constraints.length; i++) {
                for (let j = i + 1; j < constraints.length; j++) {
                    const point = findIntersection2D(constraints[i], constraints[j]);
                    if (point && checkPoint(point, constraints)) {
                        vertices.push(point);
                    }
                }
            }

            const uniqueVertices = [];
            for (let v of vertices) {
                const isDuplicate = uniqueVertices.some(u => 
                    Math.abs(u[0] - v[0]) < 0.01 && Math.abs(u[1] - v[1]) < 0.01
                );
                if (!isDuplicate) {
                    uniqueVertices.push(v);
                }
            }

            displayResults2D(uniqueVertices, objective, constraints);
        }

        function displayResults2D(vertices, objective, constraints) {
            let resultHTML = '';
            let optimalPoint = null;
            let optimalValue = objective.type === 'max' ? -Infinity : Infinity;

            if (vertices.length === 0) {
                resultHTML = '<p class="no-solution">‚ùå Aucune r√©gion r√©alisable trouv√©e</p>';
            } else {
                resultHTML += '<div class="vertices-list"><strong>Sommets de la r√©gion r√©alisable:</strong><br>';
                
                for (let v of vertices) {
                    const z = evaluateObjective(v, objective);
                    const isOptimal = (objective.type === 'max' && z > optimalValue) || 
                                     (objective.type === 'min' && z < optimalValue);
                    
                    if (isOptimal) {
                        optimalValue = z;
                        optimalPoint = v;
                    }
                    
                    resultHTML += `<div class="vertex-item">
                        (${v[0].toFixed(3)}, ${v[1].toFixed(3)}) ‚Üí Z = ${z.toFixed(3)}
                    </div>`;
                }
                
                resultHTML += '</div>';
                
                if (optimalPoint) {
                    const action = objective.type === 'max' ? 'Maximum' : 'Minimum';
                    resultHTML += `
                        <div class="optimal-solution">
                            ‚ú® Solution Optimale: ${action}<br>
                            x = ${optimalPoint[0].toFixed(3)}, y = ${optimalPoint[1].toFixed(3)}<br>
                            Z = ${optimalValue.toFixed(3)}
                        </div>
                    `;
                }
            }

            document.getElementById('resultContent').innerHTML = resultHTML;
            document.getElementById('resultSection').style.display = 'block';

            drawGraph(constraints.slice(0, numConstraints), vertices, optimalPoint, objective);
        }

        function solveND(objective, constraints) {
            let resultHTML = `
                <div class="warning-box">
                    ‚ö†Ô∏è <strong>Limitation:</strong> La r√©solution graphique compl√®te n'est pas disponible pour ${numVars} variables.
                    <br><br>
                    Pour r√©soudre ce probl√®me, vous pouvez utiliser:
                    <ul style="margin-top: 10px;">
                        <li>La m√©thode du Simplexe</li>
                        <li>Des outils comme Excel Solver, Python (scipy.optimize), ou MATLAB</li>
                    </ul>
                    <br>
                    <strong>Votre probl√®me:</strong><br>
                    ${objective.type === 'max' ? 'Maximiser' : 'Minimiser'} Z = ${objective.coeffs.map((c, i) => `${c}x${i+1}`).join(' + ')}
                </div>
            `;
            
            document.getElementById('resultContent').innerHTML = resultHTML;
            document.getElementById('resultSection').style.display = 'block';
        }

        function drawGraph(constraints, vertices, optimal, objective) {
            // Calculer les limites du graphique
            let xMax = 25;
            let yMax = 25;
            
            if (vertices.length > 0) {
                xMax = Math.max(xMax, ...vertices.map(v => v[0])) * 1.2;
                yMax = Math.max(yMax, ...vertices.map(v => v[1])) * 1.2;
            }

            const datasets = [];
            const colors = ['#667eea', '#764ba2', '#f093fb', '#4facfe', '#43e97b', '#fa709a', '#fee140', '#30cfd0', '#a8edea', '#fed6e3'];

            // Tracer TOUTES les droites des contraintes
            for (let i = 0; i < constraints.length; i++) {
                const c = constraints[i];
                const lineData = [];

                // Cas o√π le coefficient de y est non nul
                if (Math.abs(c.coeffs[1]) > 0.0001) {
                    // Tracer la droite compl√®te (trier les points par x)
                    const points = [];
                    for (let x = 0; x <= xMax; x += 0.5) {
                        const y = (c.rhs - c.coeffs[0] * x) / c.coeffs[1];
                        points.push({ x: x, y: y });
                    }
                    lineData.push(...points);
                } 
                // Cas o√π c'est une droite verticale (coefficient de y = 0)
                else if (Math.abs(c.coeffs[0]) > 0.0001) {
                    const xVal = c.rhs / c.coeffs[0];
                    lineData.push({ x: xVal, y: 0 });
                    lineData.push({ x: xVal, y: yMax });
                }

                if (lineData.length > 0) {
                    datasets.push({
                        label: `C${i+1}: ${c.coeffs[0].toFixed(1)}x + ${c.coeffs[1].toFixed(1)}y ${c.op} ${c.rhs}`,
                        data: lineData,
                        borderColor: colors[i % colors.length],
                        borderWidth: 3,
                        pointRadius: 0,
                        fill: false,
                        tension: 0,
                        showLine: true
                    });
                }
            }

            // Tracer tous les points d'intersection (sommets r√©alisables)
            if (vertices.length > 0) {
                datasets.push({
                    label: 'Sommets r√©alisables',
                    data: vertices.map(v => ({ x: v[0], y: v[1] })),
                    borderColor: '#ffc107',
                    backgroundColor: '#ffc107',
                    pointRadius: 10,
                    pointHoverRadius: 12,
                    pointStyle: 'cross',
                    pointBorderWidth: 3,
                    showLine: false
                });
            }

            // Marquer le point optimal avec une croix encore plus visible
            if (optimal) {
                datasets.push({
                    label: `‚ú® Solution optimale: (${optimal[0].toFixed(2)}, ${optimal[1].toFixed(2)})`,
                    data: [{ x: optimal[0], y: optimal[1] }],
                    borderColor: '#28a745',
                    backgroundColor: '#28a745',
                    pointRadius: 15,
                    pointHoverRadius: 18,
                    pointStyle: 'crossRot',
                    pointBorderWidth: 4,
                    showLine: false
                });
            }

            if (chart) chart.destroy();

            const ctx = document.getElementById('myChart').getContext('2d');
            chart = new Chart(ctx, {
                type: 'line',
                data: { datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: { font: { size: 11 } }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            min: 0,
                            max: xMax,
                            title: { display: true, text: 'x', font: { size: 16, weight: 'bold' } },
                            grid: { 
                                color: 'rgba(0, 0, 0, 0.1)',
                                drawBorder: true,
                                lineWidth: 1
                            },
                            ticks: { stepSize: Math.ceil(xMax / 10) }
                        },
                        y: {
                            type: 'linear',
                            min: 0,
                            max: yMax,
                            title: { display: true, text: 'y', font: { size: 16, weight: 'bold' } },
                            grid: { 
                                color: 'rgba(0, 0, 0, 0.1)',
                                drawBorder: true,
                                lineWidth: 1
                            },
                            ticks: { stepSize: Math.ceil(yMax / 10) }
                        }
                    }
                }
            });
        }

        // Initialisation
        validateAndGenerate();
        generateProblem();
    </script>
</body>
</html>
